# yanbao AI - å¤§å¸ˆåŠŸèƒ½ä¸è®°å¿†ç³»ç»Ÿ

## ğŸ“ å¤§å¸ˆåŠŸèƒ½ (Master Mode)

### æ¦‚è¿°

å¤§å¸ˆåŠŸèƒ½æ˜¯ yanbao AI çš„æ ¸å¿ƒ AI èƒ½åŠ›ï¼Œé€šè¿‡é«˜åº¦å®šåˆ¶çš„ Prompt è§’è‰²æ‰®æ¼”ï¼Œä¸ºç”¨æˆ·æä¾›ä¸“ä¸šçº§çš„æ‘„å½±ã€ç¼–è¾‘å’Œåœ°ç‚¹æ¨èå»ºè®®ã€‚

---

## ğŸ“¸ å¤§å¸ˆç±»å‹

### 1. æ‘„å½±å¤§å¸ˆ (Photography Master)

**èŒè´£**:
- æ‹æ‘„æ„å›¾å»ºè®®
- å…‰çº¿åˆ†æä¸å»ºè®®
- ç›¸æœºå‚æ•°æ¨è
- æ‹æ‘„æ—¶æœºæŒ‡å¯¼

**ç¤ºä¾‹å¯¹è¯**:
```
ç”¨æˆ·: "æˆ‘æƒ³åœ¨å¤–æ»©æ‹å¤œæ™¯ï¼Œæ€ä¹ˆæ‹æ¯”è¾ƒå¥½ï¼Ÿ"

æ‘„å½±å¤§å¸ˆ: "æ ¹æ®ä½ çš„åå¥½ï¼ˆå†·è‰²è°ƒã€ç®€çº¦é£æ ¼ï¼‰ï¼Œæˆ‘å»ºè®®ï¼š
1. æœ€ä½³æ—¶é—´ï¼šæ—¥è½å30åˆ†é’Ÿï¼ˆè“è°ƒæ—¶åˆ»ï¼‰
2. æ„å›¾ï¼šä½¿ç”¨ä¸‰åˆ†æ³•ï¼Œå°†ä¸œæ–¹æ˜ç æ”¾åœ¨å³ä¾§ä¸‰åˆ†çº¿
3. å‚æ•°ï¼šISO 800, f/8, å¿«é—¨ 1/60s
4. æŠ€å·§ï¼šä½¿ç”¨ä¸‰è„šæ¶ï¼Œå¼€å¯é•¿æ›å…‰æ¨¡å¼"
```

### 2. ç¼–è¾‘å¤§å¸ˆ (Editing Master)

**èŒè´£**:
- è°ƒè‰²æ–¹æ¡ˆæ¨è
- æ»¤é•œé€‰æ‹©å»ºè®®
- å‚æ•°è°ƒèŠ‚æŒ‡å¯¼
- é£æ ¼åŒ¹é…åˆ†æ

**ç¤ºä¾‹å¯¹è¯**:
```
ç”¨æˆ·: "è¿™å¼ ç…§ç‰‡æ€ä¹ˆè°ƒè‰²ï¼Ÿ"

ç¼–è¾‘å¤§å¸ˆ: "åˆ†æä½ çš„ç…§ç‰‡å’Œå†å²åå¥½ï¼š
1. æ¨èæ»¤é•œï¼šéœ“è™¹ï¼ˆNeonï¼‰
2. å‚æ•°è°ƒæ•´ï¼š
   - äº®åº¦ +10
   - å¯¹æ¯”åº¦ +20
   - é¥±å’Œåº¦ -5
3. ç†ç”±ï¼šä½ å–œæ¬¢èµ›åšæœ‹å…‹é£æ ¼ï¼Œè¿™ä¸ªé…æ–¹èƒ½çªå‡ºåŸå¸‚å¤œæ™¯çš„éœ“è™¹æ„Ÿ"
```

### 3. åœ°ç‚¹å¤§å¸ˆ (Location Master)

**èŒè´£**:
- æ‹æ‘„åœ°ç‚¹æ¨è
- æœ€ä½³æ—¶é—´å»ºè®®
- è·¯çº¿è§„åˆ’
- æ‹æ‘„æŠ€å·§æç¤º

**ç¤ºä¾‹å¯¹è¯**:
```
ç”¨æˆ·: "æ¨èä¸Šæµ·é€‚åˆæ‹ç…§çš„åœ°æ–¹"

åœ°ç‚¹å¤§å¸ˆ: "åŸºäºä½ çš„ä½ç½®å’Œåå¥½ï¼š
1. æ­¦åº·è·¯ï¼ˆè·ç¦» 2.3kmï¼‰
   - ç‰¹è‰²ï¼šæ³•å¼æ¢§æ¡ã€å¤å¤å»ºç­‘
   - æœ€ä½³æ—¶é—´ï¼šä¸‹åˆ 3-5 ç‚¹
   - æ‹æ‘„å»ºè®®ï¼šä½¿ç”¨ 50mm é•œå¤´æ‹æ‘„è¡—æ™¯
2. ç”°å­åŠï¼ˆè·ç¦» 3.1kmï¼‰
   - ç‰¹è‰²ï¼šçŸ³åº“é—¨ã€æ–‡è‰ºå°åº—
   - æœ€ä½³æ—¶é—´ï¼šä¸Šåˆ 10-12 ç‚¹
   - æ‹æ‘„å»ºè®®ï¼šæ•æ‰å…‰å½±å¯¹æ¯”"
```

---

## ğŸ§  æŠ€æœ¯å®ç°

### Python åç«¯å®ç°

```python
# master_processor.py
import openai
from typing import Dict, List, Optional
import json

class MasterProcessor:
    """
    yanbao AI å¤§å¸ˆåŠŸèƒ½æ ¸å¿ƒå¤„ç†å™¨
    """
    
    def __init__(self, user_id: str, master_type: str):
        """
        åˆå§‹åŒ–å¤§å¸ˆå¤„ç†å™¨
        
        Args:
            user_id: ç”¨æˆ· ID
            master_type: å¤§å¸ˆç±»å‹ ('photography', 'editing', 'location')
        """
        self.user_id = user_id
        self.master_type = master_type
        self.memory = self._load_user_memory()
        self.client = openai.OpenAI()
        
    def _load_user_memory(self) -> Dict:
        """
        ä»è®°å¿†ç³»ç»ŸåŠ è½½ç”¨æˆ·è®°å¿†
        
        Returns:
            ç”¨æˆ·è®°å¿†å­—å…¸
        """
        # ä»å‘é‡æ•°æ®åº“æ£€ç´¢ç”¨æˆ·è®°å¿†
        memory_service = MemoryService(self.user_id)
        return memory_service.get_relevant_memories(
            query=f"{self.master_type} preferences",
            top_k=5
        )
    
    def _build_system_prompt(self) -> str:
        """
        æ„å»ºå¤§å¸ˆè§’è‰²çš„ç³»ç»Ÿæç¤ºè¯
        
        Returns:
            ç³»ç»Ÿæç¤ºè¯å­—ç¬¦ä¸²
        """
        role_prompts = {
            'photography': """
ä½ æ˜¯ yanbao AI çš„æ‘„å½±å¤§å¸ˆã€‚ä½ æ‹¥æœ‰ 20 å¹´ä¸“ä¸šæ‘„å½±ç»éªŒï¼Œæ“…é•¿ï¼š
- æ„å›¾åˆ†æä¸å»ºè®®
- å…‰çº¿è¯„ä¼°ä¸è¿ç”¨
- ç›¸æœºå‚æ•°è®¾ç½®
- æ‹æ‘„æ—¶æœºæŠŠæ¡

è¯·ç»“åˆç”¨æˆ·çš„æ‹æ‘„ä¹ æƒ¯å’Œå®¡ç¾åå¥½ï¼Œæä¾›ä¸“ä¸šã€ä¸ªæ€§åŒ–çš„å»ºè®®ã€‚
""",
            'editing': """
ä½ æ˜¯ yanbao AI çš„ç¼–è¾‘å¤§å¸ˆã€‚ä½ ç²¾é€šç…§ç‰‡åæœŸå¤„ç†ï¼Œæ“…é•¿ï¼š
- è°ƒè‰²æ–¹æ¡ˆè®¾è®¡
- æ»¤é•œæ•ˆæœæ¨è
- å‚æ•°ç²¾ç»†è°ƒèŠ‚
- é£æ ¼åŒ¹é…åˆ†æ

è¯·æ ¹æ®ç”¨æˆ·çš„å†å²ç¼–è¾‘è®°å½•å’Œå®¡ç¾åå¥½ï¼Œæä¾›ç²¾å‡†çš„è°ƒè‰²å»ºè®®ã€‚
""",
            'location': """
ä½ æ˜¯ yanbao AI çš„åœ°ç‚¹å¤§å¸ˆã€‚ä½ ç†Ÿæ‚‰å…¨å›½å„åœ°çš„æ‹æ‘„åœ°ç‚¹ï¼Œæ“…é•¿ï¼š
- æ‹æ‘„åœ°ç‚¹æ¨è
- æœ€ä½³æ—¶é—´å»ºè®®
- è·¯çº¿è§„åˆ’
- æ‹æ‘„æŠ€å·§æç¤º

è¯·ç»“åˆç”¨æˆ·çš„ä½ç½®ã€åå¥½å’Œå†å²è¶³è¿¹ï¼Œæ¨èæœ€åˆé€‚çš„æ‹æ‘„åœ°ç‚¹ã€‚
"""
        }
        
        base_prompt = role_prompts.get(self.master_type, "")
        
        # æ³¨å…¥ç”¨æˆ·è®°å¿†
        memory_context = self._format_memory_context()
        
        return f"""{base_prompt}

ç”¨æˆ·èƒŒæ™¯ä¿¡æ¯ï¼š
{memory_context}

è¯·ç”¨ç®€ä½“ä¸­æ–‡å›ç­”ï¼Œè¯­æ°”ä¸“ä¸šä½†äº²åˆ‡ã€‚
"""
    
    def _format_memory_context(self) -> str:
        """
        æ ¼å¼åŒ–ç”¨æˆ·è®°å¿†ä¸ºä¸Šä¸‹æ–‡
        
        Returns:
            æ ¼å¼åŒ–çš„è®°å¿†å­—ç¬¦ä¸²
        """
        if not self.memory:
            return "æš‚æ— ç”¨æˆ·å†å²è®°å½•"
        
        context_parts = []
        
        if 'preferences' in self.memory:
            prefs = self.memory['preferences']
            context_parts.append(f"å®¡ç¾åå¥½ï¼š{', '.join(prefs)}")
        
        if 'habits' in self.memory:
            habits = self.memory['habits']
            context_parts.append(f"æ‹æ‘„ä¹ æƒ¯ï¼š{', '.join(habits)}")
        
        if 'favorite_locations' in self.memory:
            locs = self.memory['favorite_locations']
            context_parts.append(f"å¸¸å»åœ°ç‚¹ï¼š{', '.join(locs)}")
        
        return "\n".join(context_parts)
    
    def generate_response(self, user_input: str, context: Optional[Dict] = None) -> Dict:
        """
        ç”Ÿæˆå¤§å¸ˆå»ºè®®
        
        Args:
            user_input: ç”¨æˆ·è¾“å…¥
            context: é¢å¤–ä¸Šä¸‹æ–‡ï¼ˆå¦‚ç…§ç‰‡å…ƒæ•°æ®ã€ä½ç½®ä¿¡æ¯ç­‰ï¼‰
        
        Returns:
            åŒ…å«å»ºè®®å’Œå…ƒæ•°æ®çš„å­—å…¸
        """
        # æ„å»ºæ¶ˆæ¯åˆ—è¡¨
        messages = [
            {"role": "system", "content": self._build_system_prompt()},
            {"role": "user", "content": user_input}
        ]
        
        # å¦‚æœæœ‰é¢å¤–ä¸Šä¸‹æ–‡ï¼Œæ·»åŠ åˆ°ç”¨æˆ·æ¶ˆæ¯
        if context:
            context_str = json.dumps(context, ensure_ascii=False)
            messages.append({
                "role": "user",
                "content": f"é¢å¤–ä¿¡æ¯ï¼š{context_str}"
            })
        
        # è°ƒç”¨å¤§æ¨¡å‹
        response = self.client.chat.completions.create(
            model="gpt-4",
            messages=messages,
            temperature=0.7,
            max_tokens=500
        )
        
        advice = response.choices[0].message.content
        
        # å¼‚æ­¥æ›´æ–°è®°å¿†
        self._update_memory_async(user_input, advice)
        
        return {
            "advice": advice,
            "master_type": self.master_type,
            "confidence": 0.9,  # å¯ä»¥é€šè¿‡æ¨¡å‹è¾“å‡ºè®¡ç®—
            "timestamp": int(time.time())
        }
    
    def _update_memory_async(self, user_input: str, advice: str):
        """
        å¼‚æ­¥æ›´æ–°ç”¨æˆ·è®°å¿†
        
        Args:
            user_input: ç”¨æˆ·è¾“å…¥
            advice: å¤§å¸ˆå»ºè®®
        """
        # æå–å…³é”®ä¿¡æ¯å¹¶æ›´æ–°è®°å¿†
        memory_service = MemoryService(self.user_id)
        memory_service.update_from_interaction(
            user_input=user_input,
            ai_response=advice,
            interaction_type=self.master_type
        )


# ä½¿ç”¨ç¤ºä¾‹
if __name__ == "__main__":
    # åˆå§‹åŒ–æ‘„å½±å¤§å¸ˆ
    master = MasterProcessor(
        user_id="user_123",
        master_type="photography"
    )
    
    # ç”¨æˆ·è¯·æ±‚å»ºè®®
    response = master.generate_response(
        user_input="æˆ‘æƒ³åœ¨å¤–æ»©æ‹å¤œæ™¯ï¼Œæ€ä¹ˆæ‹æ¯”è¾ƒå¥½ï¼Ÿ",
        context={
            "location": {"lat": 31.2397, "lng": 121.4912},
            "time": "18:30",
            "weather": "æ™´"
        }
    )
    
    print(response["advice"])
```

### TypeScript å‰ç«¯å®ç°

```typescript
// MasterService.ts
import axios from 'axios';

interface MasterRequest {
  userId: string;
  masterType: 'photography' | 'editing' | 'location';
  userInput: string;
  context?: Record<string, any>;
}

interface MasterResponse {
  advice: string;
  masterType: string;
  confidence: number;
  timestamp: number;
}

class MasterService {
  private apiUrl: string;

  constructor() {
    this.apiUrl = process.env.API_URL || 'https://api.yanbao.ai';
  }

  async getAdvice(request: MasterRequest): Promise<MasterResponse> {
    try {
      const response = await axios.post<MasterResponse>(
        `${this.apiUrl}/api/v1/master/advice`,
        request,
        {
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this.getToken()}`,
          },
        }
      );

      return response.data;
    } catch (error) {
      console.error('Master service error:', error);
      throw error;
    }
  }

  private getToken(): string {
    // ä»æœ¬åœ°å­˜å‚¨è·å– JWT token
    return localStorage.getItem('auth_token') || '';
  }
}

export default new MasterService();
```

---

## ğŸ’¾ é›å®è®°å¿†ç³»ç»Ÿ (yanbao Memory)

### æ¦‚è¿°

é›å®è®°å¿†ç³»ç»Ÿè®© AI èƒ½å¤Ÿè®°ä½ç”¨æˆ·çš„åå¥½ã€ä¹ æƒ¯å’Œå†å²ï¼Œæä¾›ä¸ªæ€§åŒ–çš„æœåŠ¡ã€‚

---

## ğŸ§© è®°å¿†ç±»å‹

### 1. çŸ­æœŸè®°å¿† (Short-term Memory)

**å­˜å‚¨**: Redis  
**ç”Ÿå‘½å‘¨æœŸ**: 24 å°æ—¶  
**ç”¨é€”**: ä¼šè¯ä¸Šä¸‹æ–‡ã€ä¸´æ—¶åå¥½

```python
# çŸ­æœŸè®°å¿†ç¤ºä¾‹
short_term_memory = {
    "session_id": "sess_abc123",
    "user_id": "user_123",
    "context": [
        {"role": "user", "content": "æˆ‘æƒ³æ‹å¤œæ™¯"},
        {"role": "assistant", "content": "æ¨èå¤–æ»©..."}
    ],
    "temp_preferences": {
        "current_location": {"lat": 31.2397, "lng": 121.4912},
        "current_mood": "æ¢ç´¢"
    },
    "expires_at": 1705449600
}
```

### 2. é•¿æœŸè®°å¿† (Long-term Memory)

**å­˜å‚¨**: å‘é‡æ•°æ®åº“ (Pinecone/Milvus)  
**ç”Ÿå‘½å‘¨æœŸ**: æ°¸ä¹…  
**ç”¨é€”**: ç”¨æˆ·åå¥½ã€ä¹ æƒ¯ã€é…æ–¹

```python
# é•¿æœŸè®°å¿†ç¤ºä¾‹
long_term_memory = {
    "memory_id": "mem_xyz789",
    "user_id": "user_123",
    "memory_type": "preference",
    "content": "ç”¨æˆ·åå¥½å†·è‰²è°ƒã€ç®€çº¦é£æ ¼çš„ç…§ç‰‡",
    "embedding": [0.123, 0.456, ...],  # 1536 ç»´å‘é‡
    "metadata": {
        "confidence": 0.95,
        "source": "editing_history",
        "created_at": "2026-01-15T10:30:00Z",
        "updated_at": "2026-01-17T15:45:00Z"
    }
}
```

---

## ğŸ”„ è®°å¿†å·¥ä½œæµç¨‹

### 1. è®°å¿†æå– (Memory Extraction)

```python
# memory_extractor.py
from typing import List, Dict
import re

class MemoryExtractor:
    """
    ä»ç”¨æˆ·äº¤äº’ä¸­æå–è®°å¿†
    """
    
    def extract_entities(self, text: str) -> Dict[str, List[str]]:
        """
        æå–å®ä½“ï¼ˆæ—¥æœŸã€åœ°ç‚¹ã€åå¥½ç­‰ï¼‰
        
        Args:
            text: ç”¨æˆ·è¾“å…¥æ–‡æœ¬
        
        Returns:
            å®ä½“å­—å…¸
        """
        entities = {
            "locations": [],
            "times": [],
            "preferences": [],
            "actions": []
        }
        
        # æå–åœ°ç‚¹
        location_patterns = [
            r'åœ¨(.{2,10}?)æ‹',
            r'å»(.{2,10}?)æ‹ç…§',
            r'(.{2,10}?)çš„é£æ™¯'
        ]
        for pattern in location_patterns:
            matches = re.findall(pattern, text)
            entities["locations"].extend(matches)
        
        # æå–æ—¶é—´
        time_patterns = [
            r'(æ—©ä¸Š|ä¸Šåˆ|ä¸­åˆ|ä¸‹åˆ|å‚æ™š|æ™šä¸Š|å¤œæ™š)',
            r'(\d{1,2}[ç‚¹æ—¶])',
            r'(æ—¥å‡º|æ—¥è½|é»„æ˜|è“è°ƒæ—¶åˆ»)'
        ]
        for pattern in time_patterns:
            matches = re.findall(pattern, text)
            entities["times"].extend(matches)
        
        # æå–åå¥½
        preference_keywords = [
            'å–œæ¬¢', 'åå¥½', 'å¸¸ç”¨', 'ç»å¸¸', 'ä¹ æƒ¯',
            'å†·è‰²è°ƒ', 'æš–è‰²è°ƒ', 'ç®€çº¦', 'å¤å¤', 'æ–‡è‰º'
        ]
        for keyword in preference_keywords:
            if keyword in text:
                entities["preferences"].append(keyword)
        
        return entities
    
    def create_memory(self, entities: Dict, context: str) -> Dict:
        """
        åˆ›å»ºè®°å¿†å¯¹è±¡
        
        Args:
            entities: æå–çš„å®ä½“
            context: åŸå§‹ä¸Šä¸‹æ–‡
        
        Returns:
            è®°å¿†å¯¹è±¡
        """
        memory = {
            "content": context,
            "entities": entities,
            "memory_type": self._infer_memory_type(entities),
            "importance": self._calculate_importance(entities),
            "timestamp": int(time.time())
        }
        
        return memory
    
    def _infer_memory_type(self, entities: Dict) -> str:
        """
        æ¨æ–­è®°å¿†ç±»å‹
        """
        if entities["preferences"]:
            return "preference"
        elif entities["locations"]:
            return "location"
        elif entities["times"]:
            return "habit"
        else:
            return "general"
    
    def _calculate_importance(self, entities: Dict) -> float:
        """
        è®¡ç®—è®°å¿†é‡è¦æ€§ï¼ˆ0-1ï¼‰
        """
        score = 0.5  # åŸºç¡€åˆ†
        
        # åŒ…å«åå¥½ä¿¡æ¯ï¼Œé‡è¦æ€§é«˜
        if entities["preferences"]:
            score += 0.3
        
        # åŒ…å«å¤šä¸ªå®ä½“ï¼Œé‡è¦æ€§é«˜
        total_entities = sum(len(v) for v in entities.values())
        score += min(total_entities * 0.05, 0.2)
        
        return min(score, 1.0)
```

### 2. è®°å¿†å­˜å‚¨ (Memory Storage)

```python
# memory_storage.py
from pinecone import Pinecone, ServerlessSpec
import openai
from typing import List, Dict

class MemoryStorage:
    """
    è®°å¿†å­˜å‚¨æœåŠ¡
    """
    
    def __init__(self, api_key: str, index_name: str = "yanbao-memory"):
        self.pc = Pinecone(api_key=api_key)
        self.index_name = index_name
        self.openai_client = openai.OpenAI()
        
        # åˆ›å»ºæˆ–è¿æ¥ç´¢å¼•
        if index_name not in self.pc.list_indexes().names():
            self.pc.create_index(
                name=index_name,
                dimension=1536,  # OpenAI embedding ç»´åº¦
                metric='cosine',
                spec=ServerlessSpec(
                    cloud='aws',
                    region='us-east-1'
                )
            )
        
        self.index = self.pc.Index(index_name)
    
    def store_memory(self, user_id: str, memory: Dict) -> str:
        """
        å­˜å‚¨è®°å¿†
        
        Args:
            user_id: ç”¨æˆ· ID
            memory: è®°å¿†å¯¹è±¡
        
        Returns:
            è®°å¿† ID
        """
        # ç”Ÿæˆ embedding
        embedding = self._generate_embedding(memory["content"])
        
        # ç”Ÿæˆå”¯ä¸€ ID
        memory_id = f"{user_id}_{memory['timestamp']}"
        
        # å‡†å¤‡å…ƒæ•°æ®
        metadata = {
            "user_id": user_id,
            "memory_type": memory["memory_type"],
            "importance": memory["importance"],
            "content": memory["content"],
            "timestamp": memory["timestamp"]
        }
        
        # å­˜å‚¨åˆ°å‘é‡æ•°æ®åº“
        self.index.upsert(
            vectors=[(memory_id, embedding, metadata)]
        )
        
        return memory_id
    
    def retrieve_memories(
        self,
        user_id: str,
        query: str,
        top_k: int = 5,
        filter_type: str = None
    ) -> List[Dict]:
        """
        æ£€ç´¢è®°å¿†
        
        Args:
            user_id: ç”¨æˆ· ID
            query: æŸ¥è¯¢æ–‡æœ¬
            top_k: è¿”å›æ•°é‡
            filter_type: è®°å¿†ç±»å‹è¿‡æ»¤
        
        Returns:
            è®°å¿†åˆ—è¡¨
        """
        # ç”ŸæˆæŸ¥è¯¢ embedding
        query_embedding = self._generate_embedding(query)
        
        # æ„å»ºè¿‡æ»¤æ¡ä»¶
        filter_dict = {"user_id": user_id}
        if filter_type:
            filter_dict["memory_type"] = filter_type
        
        # å‘é‡æ£€ç´¢
        results = self.index.query(
            vector=query_embedding,
            top_k=top_k,
            filter=filter_dict,
            include_metadata=True
        )
        
        # æ ¼å¼åŒ–ç»“æœ
        memories = []
        for match in results.matches:
            memories.append({
                "memory_id": match.id,
                "content": match.metadata["content"],
                "memory_type": match.metadata["memory_type"],
                "importance": match.metadata["importance"],
                "similarity": match.score,
                "timestamp": match.metadata["timestamp"]
            })
        
        return memories
    
    def _generate_embedding(self, text: str) -> List[float]:
        """
        ç”Ÿæˆæ–‡æœ¬ embedding
        
        Args:
            text: è¾“å…¥æ–‡æœ¬
        
        Returns:
            embedding å‘é‡
        """
        response = self.openai_client.embeddings.create(
            model="text-embedding-3-small",
            input=text
        )
        
        return response.data[0].embedding
```

### 3. è®°å¿†æ£€ç´¢ (Memory Retrieval)

```python
# memory_service.py
from typing import Dict, List
import redis

class MemoryService:
    """
    è®°å¿†æœåŠ¡ï¼ˆæ•´åˆçŸ­æœŸå’Œé•¿æœŸè®°å¿†ï¼‰
    """
    
    def __init__(self, user_id: str):
        self.user_id = user_id
        self.redis_client = redis.Redis(host='localhost', port=6379, db=0)
        self.storage = MemoryStorage(api_key="your-pinecone-api-key")
        self.extractor = MemoryExtractor()
    
    def get_relevant_memories(
        self,
        query: str,
        top_k: int = 5
    ) -> Dict:
        """
        è·å–ç›¸å…³è®°å¿†ï¼ˆçŸ­æœŸ + é•¿æœŸï¼‰
        
        Args:
            query: æŸ¥è¯¢æ–‡æœ¬
            top_k: è¿”å›æ•°é‡
        
        Returns:
            è®°å¿†å­—å…¸
        """
        memories = {
            "short_term": self._get_short_term_memory(),
            "long_term": self._get_long_term_memory(query, top_k)
        }
        
        return self._merge_memories(memories)
    
    def _get_short_term_memory(self) -> Dict:
        """
        è·å–çŸ­æœŸè®°å¿†ï¼ˆRedisï¼‰
        """
        key = f"user:{self.user_id}:session"
        data = self.redis_client.hgetall(key)
        
        if not data:
            return {}
        
        return {
            k.decode(): v.decode()
            for k, v in data.items()
        }
    
    def _get_long_term_memory(self, query: str, top_k: int) -> List[Dict]:
        """
        è·å–é•¿æœŸè®°å¿†ï¼ˆå‘é‡æ•°æ®åº“ï¼‰
        """
        return self.storage.retrieve_memories(
            user_id=self.user_id,
            query=query,
            top_k=top_k
        )
    
    def _merge_memories(self, memories: Dict) -> Dict:
        """
        åˆå¹¶çŸ­æœŸå’Œé•¿æœŸè®°å¿†
        """
        merged = {
            "preferences": [],
            "habits": [],
            "favorite_locations": []
        }
        
        # ä»é•¿æœŸè®°å¿†æå–
        for mem in memories["long_term"]:
            if mem["memory_type"] == "preference":
                merged["preferences"].append(mem["content"])
            elif mem["memory_type"] == "habit":
                merged["habits"].append(mem["content"])
            elif mem["memory_type"] == "location":
                merged["favorite_locations"].append(mem["content"])
        
        return merged
    
    def update_from_interaction(
        self,
        user_input: str,
        ai_response: str,
        interaction_type: str
    ):
        """
        ä»äº¤äº’ä¸­æ›´æ–°è®°å¿†
        
        Args:
            user_input: ç”¨æˆ·è¾“å…¥
            ai_response: AI å“åº”
            interaction_type: äº¤äº’ç±»å‹
        """
        # æå–å®ä½“
        entities = self.extractor.extract_entities(user_input)
        
        # åˆ›å»ºè®°å¿†
        memory = self.extractor.create_memory(
            entities=entities,
            context=f"ç”¨æˆ·: {user_input}\nAI: {ai_response}"
        )
        
        # å­˜å‚¨è®°å¿†
        if memory["importance"] > 0.6:  # åªå­˜å‚¨é‡è¦è®°å¿†
            self.storage.store_memory(self.user_id, memory)
```

---

## ğŸ“Š è®°å¿†æ•°æ®ç»“æ„

### MySQL è¡¨ç»“æ„

```sql
-- è®°å¿†è¡¨
CREATE TABLE memories (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  memory_type ENUM('preference', 'habit', 'recipe', 'location') NOT NULL,
  content TEXT NOT NULL,
  vector_id VARCHAR(100),
  importance FLOAT DEFAULT 0.5,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  FOREIGN KEY (user_id) REFERENCES users(id),
  INDEX idx_user_type (user_id, memory_type),
  INDEX idx_importance (importance)
);

-- è®°å¿†æ ‡ç­¾è¡¨
CREATE TABLE memory_tags (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  memory_id BIGINT NOT NULL,
  tag VARCHAR(50) NOT NULL,
  FOREIGN KEY (memory_id) REFERENCES memories(id),
  INDEX idx_tag (tag)
);
```

---

## ğŸ¯ æœ€ä½³å®è·µ

### 1. è®°å¿†ç®¡ç†
- âœ… å®šæœŸæ¸…ç†ä½é‡è¦æ€§è®°å¿†
- âœ… åˆå¹¶ç›¸ä¼¼è®°å¿†
- âœ… æ›´æ–°è®°å¿†æƒé‡

### 2. éšç§ä¿æŠ¤
- âœ… æ•æ„Ÿä¿¡æ¯åŠ å¯†å­˜å‚¨
- âœ… ç”¨æˆ·å¯åˆ é™¤è®°å¿†
- âœ… éµå®ˆæ•°æ®ä¿æŠ¤æ³•è§„

### 3. æ€§èƒ½ä¼˜åŒ–
- âœ… ç¼“å­˜çƒ­é—¨è®°å¿†
- âœ… å¼‚æ­¥æ›´æ–°è®°å¿†
- âœ… æ‰¹é‡å¤„ç†è®°å¿†

---

**æ–‡æ¡£ä½œè€…**: Jason Tsao  
**æ›´æ–°æ—¶é—´**: 2026å¹´1æœˆ17æ—¥  
**ç‰ˆæœ¬**: 1.0
